require 'koala'

class ApplicationController < ActionController::Base
  protect_from_forgery

  before_filter :set_region, :set_country, :set_locale,
                :set_timezone, :authenticate_with_facebook, :store_landing_information

  after_filter  :ensure_sailthru_cookie

  helper_method :current_user, :current_customer, :user_signed_in?, :facebook_creds,
                :facebook_locale, :user_signed_in_with_facebook?,
                :current_country, :current_region, :current_reservation_params,
                :mobile_device?, :full_restaurant_url, :new_landing?, :landing_source

  include Redo::UrlHelper
  include RedoMobile

  HOSTNAME_RX = /^(([a-z]|\-)+)\.#{RedoApp.domain_name}\.(?:com\.([a-z]{2})|([a-z]{2}))$/i.freeze
  RESERVATION_PARAMS_COOKIE = "_redo_rps".freeze
  REGION_COOKIE = "_redo_region".freeze


#  rescue_from ActiveRecord::RecordNotFound do |exception|
#    render_error(404)
#  end
#
#  rescue_from AbstractController::ActionNotFound do |exception|
#    render_error(404)
#  end

  private

  def render_error(status)
    respond_to do |wants|
      wants.html { render "errors/#{status}", status: status, layout: nil }
      wants.any  { head status }
    end
  end

  def set_region
    return if request.host == RedoApp.root_home_host

    cr = extract_region_and_country_from_host
    if not cr
      redirect_to RedoApp.root_home_url(request.port)
      return
    end

    country = RCore::Country.find(cr[:country])
    region = RCore::Region.find(cr[:region])
    if region.blank? || region.country != country || region.disabled?
      cookie_region = region_from_cookie
      if cookie_region
        redirect_to cookie_region.url(request.port), flash: {redirect: true}
      elsif country
        redirect_to country.default_region.url(request.port), flash: {redirect: true}
      else
        redirect_to RedoApp.root_home_url(request.port)
      end

      return
    end

    @current_region = region

    @region_not_selected = cookies[REGION_COOKIE].blank? && flash[:redirect]

    persist_current_region
  end

  def set_country
    return if @current_region.present?

    tld = request.host.split(".")[-1]
    @current_country = RCore::Country.find(tld)
  end

  def set_locale
    locale = I18n.default_locale
    if params[:locale].present? &&
        RCore.config.supported_locales.include?(params[:locale])
      @locale_from_params = true
      locale = params[:locale]
    elsif current_country.present?
      locale = current_country.locale
    end

    I18n.locale = locale
  end

  def set_timezone
    Time.zone = current_region.timezone if current_region.present?
  end

  def current_region
    @current_region
  end

  def current_country
    current_region.present? ? current_region.country : @current_country
  end

  def current_user
    @current_user ||= Redo::User.find(session[:user_id]) if session[:user_id]
  end

  def current_customer
    @current_customer ||= CustomerPresenter.new(current_user.customer) if current_user
  end

  def user_signed_in?
    current_user.present?
  end

  def facebook_creds
    Redo.facebook_creds(current_country.code) if current_country.present?
  end

  def facebook_locale
    I18n.locale.to_sym == :"pt-BR" ? 'pt_BR' : 'es_LA'
  end

  def require_authentication
    return if current_user.present?

    redirect_to sign_up_path
  end

  def sign_in!(user, opts = {})
    session[:user_id] = user.id
    user.track_sign_in!
    session[:fb_login] = true if opts[:fb_login]
  end

  def sign_out!
    session[:user_id] = nil
    session[:fb_login] = nil

    # delete facebook connect cookies
    %w[fbsr fbm].each do |cookie|
      cookies.delete "#{cookie}_#{facebook_creds["app_id"]}", domain: current_country.domain
    end
  end

  def user_signed_in_with_facebook?
    !!session[:fb_login]
  end

  def authenticate_with_facebook
    return if current_region.blank?
    return if user_signed_in?

    oauth = Koala::Facebook::OAuth.new(facebook_creds['app_id'],
                                       facebook_creds['app_secret'])
    user_info = oauth.get_user_info_from_cookies(cookies)

    return unless user_info.present?
    return unless user_info["user_id"].present?

    user = Redo::User.find_by_fb_uid(user_info["user_id"])
    if user.blank?
      user = Redo::User.signup_with_facebook!(user_info["access_token"],
                                        current_region, referral_token: params[:referral_token])
      unless user.nil?
        flash[:signup_method] = 'Facebook'
        Redo::EventEmitter.trigger 'new.user', user
      end
    end

    # user didn't grant access to email address
    return if user.nil?

    sign_in!(user, :fb_login => true)
  rescue Koala::Facebook::APIError => e
    notify_airbrake(e) unless e.fb_error_code == 100
  end

  def extract_region_and_country_from_host
    if request.host =~ HOSTNAME_RX
      { :region => $1, :country => $3 || $4 }
    else
      nil
    end
  end

  def current_reservation_params
    current_reservation_info.params
  end

  def current_reservation_info
    @current_reservation_info ||= begin
      informed_params = params.slice(:date, :time, :diners).reverse_merge(read_reservation_params)
      reservation_params = ReservationParams.new(current_region, informed_params)
      informed_params.keys.each do |param_key|
        param_key = param_key.to_sym
        write_reservation_params(param_key, reservation_params.params[param_key])
      end
      reservation_params
    end
  end

  def read_reservation_params(key = nil)
    cookie_val = cookies[RESERVATION_PARAMS_COOKIE] || "{}"
    rps = JSON.parse(cookie_val)
    key.blank? ? rps.symbolize_keys! : rps[key]
  end

  def write_reservation_params(key, val)
    rps = read_reservation_params
    rps[key.to_sym] = val
    cookies[RESERVATION_PARAMS_COOKIE] = rps.to_json
    rps
  end

  def persist_current_region
    # persist region if necessary
    region = current_region
    region_cookie_value = "#{region.code},#{region.country.code}"
    if cookies[REGION_COOKIE] != region_cookie_value
      cookies.permanent[REGION_COOKIE] = {
        :value => region_cookie_value,
        :domain => region.country.domain
      }
    end
  end

  def region_from_cookie
    region_cookie_value = cookies[REGION_COOKIE]
    return nil if region_cookie_value.blank?
    region, country = region_cookie_value.split(",")
    RCore::Region.find(region)
  end

  def ensure_sailthru_cookie
    return unless user_signed_in? && cookies[:sailthru_hid].blank?

    response = Timeout::timeout(2) do
      Redo::SailthruJob.perform('save_user', current_user.email, fields: { keys: 1 })
    end

    cookies[:sailthru_hid] = response['keys']['cookie']
  rescue Redo::SailthruApiError, Timeout::Error, Sailthru::SailthruClientException => e
    Rails.logger.error e.message
  end

  def store_landing_information
    if new_landing? && request.get? && !request.xhr?
      referrer = (request.referrer || "").truncate(512).presence

      marketing_params = params.select {|k, _| k =~ /^(utm|redomkt|gclid)/ }
      other_params     = params.reject {|k, _| k =~ /^(utm|redomkt|gclid)/ }
      landing_params[:referrer] = referrer
      session[:landing_params]  = marketing_params
      session[:landing_url]     = url_for(other_params).truncate(512)
      write_reservation_params(:referrer, referrer) if request.referrer
    end
  end

  def landing_url
    session[:landing_url]
  end

  def landing_params
    session[:landing_params] || {}
  end

  def landing_source
    cookies[:landing_source]
  end

  def clear_landing_information!
    session.delete :landing_params
    session.delete :landing_url
  end

  def new_landing?
    @new_landing ||= current_country && request.referrer !~ %r{#{Regexp.escape current_country.domain}}
  end

end
