require 'bcrypt'
require 'validates_as_email_address'

module Redo
  class User < PersistentRecord
    attr_reader :password
    attr_protected :password_digest

    # Associations
    belongs_to :customer, class_name: "RCore::Customer", autosave: true

    has_many :reviews
    has_many :favorites
    has_many :favorite_restaurants, :through => :favorites, :source => :restaurant
    has_many :payments, through: :customer
    has_many :credit_cards, through: :customer

    # The invitations created by this user
    has_many :referrals

    # The invitation received by this user
    has_one :referral, foreign_key: :referred_user_id

    # The user from whom this user received the invitation
    has_one :referer, through: :referral, source: :user

    # Validations
    validates_associated :customer
    validates_presence_of :password_digest, :if => :registered?
    validates_confirmation_of :password

    # Scopes
    scope :registered, where(:registered => true)
    scope :local_to, lambda { |region, country|
      joins(:customer).where(customers: { region: region.to_s, country: country.to_s })
    }
    scope :for_emailing, lambda {
      where(:registered => true, :accepts_emails => true)
        .where("confirmed_at IS NOT NULL")
    }
    scope :with_photo, where("#{quoted_table_name}.avatar IS NOT NULL or #{quoted_table_name}.fb_uid IS NOT NULL")

    # Callbacks
    after_create { ensure_authentication_token! }
    after_update { trigger 'update.user', self }
    after_initialize :initialize_customer

    mount_uploader :avatar, UserAvatarUploader

    delegate :credit, to: :customer, allow_nil: true

    def self.find_by_email(email)
      includes(:customer).where(customers: { email: email }).first
    end

    def self.find_by_email!(email)
      find_by_email(email) or raise ActiveRecord::RecordNotFound
    end

    def self.find_or_initialize_by_email(email)
      find_by_email(email) || new(customer: RCore::Customer.find_or_initialize_by_email(email))
    end

    def self.find_or_initialize_by_customer(customer)
      find_by_customer_id(customer.id) || new(customer: customer)
    end

    def self.from_customer(customer)
      find_by_customer_id(customer.id)
    end

    def self.generate_token
      o =  [('a'..'z'),(0..9)].map{|i| i.to_a}.flatten
      (0..10).map{ o[rand(o.length)] }.join
    end

    def self.confirm_by_token(token)
      user = self.find_by_confirmation_token(token)
      return if user.blank?
      user.confirm!
      user
    end

    def self.signup!(attributes, region, *args)
      options = args.extract_options!

      user = User.find_or_initialize_by_email(attributes[:email])
      if user.registered?
        user.errors[:base] = I18n.t("users.errors.already_registered")
        return user
      end

      attributes = attributes.merge(registered: true, points: Redo.config.signup_points)
      attributes.merge!(region: region.id, country: region.country.id) if region.present?

      user.assign_attributes(attributes)
      user.assign_referral(options[:referral_token])

      if user.save && !user.confirmed?
        user.send_confirmation_instructions!(region)
      end

      user
    end

    # Assigns a referral to this user setting its *referral* attribute. If the
    # user is a new record the referral will not be saved.
    def assign_referral referral_token
      if referral_token.present?
        self.referral = Redo::Referral.fetch_with_token(
          referral_token['value'],
          referral_token['type'],
          referral_token['strategy'])

        # The user is signing up, so change the status
        self.referral.status = Redo::Referral::STATUS_REGISTERED

        # Add pending points
        self.points += self.referral.referred_user_points
      end
    end

    def self.signup_with_facebook!(access_token, region, *args)
      options = args.extract_options!

      graph = Koala::Facebook::API.new(access_token)
      fb_profile = graph.get_object("me")

      # user didn't grant access to email address
      return if fb_profile["email"].blank?

      user = User.find_or_initialize_by_email(fb_profile["email"])

      user.first_name = fb_profile["first_name"]
      user.last_name = fb_profile["last_name"]
      if fb_profile["birthday"].present?
        user.birthday = Time.strptime(fb_profile["birthday"], "%m/%d/%Y").to_date
      end
      user.fb_uid = fb_profile["id"]
      if user.new_record?
        user.email = fb_profile["email"]
        user.confirmed_at = Time.now
      elsif user.email == fb_profile["email"] && user.confirmed_at.blank?
        user.confirm!
      end

      unless user.registered?
        user.registered = true
        user.points = Redo.config.signup_points
        user.region = region.id
        user.country = region.country.id
        user.credit = Money.new(0, region.country.currency)
      end

      if user.password_digest.blank?
        user.password = self.generate_token
      end

      user.customer.verified = true
      user.assign_referral(options[:referral_token])
      user.save!

      user
    end

    def self.who_recommend(restaurant)
      User.select('DISTINCT(redo_users.id), redo_users.*')
          .joins(:reviews).merge(Review.positive)
          .where('redo_feedbacks.restaurant_id = ?', restaurant.id)
    end

    def authenticate(unencrypted_password)
      return false if unencrypted_password.blank?
      return false if self.password_digest.blank?

      if password_digest =~ /^legacy\|/
        digest = Digest::MD5.hexdigest(unencrypted_password)
        return false if digest != self.password_digest.gsub(/^legacy\|/, '')
        self.password = unencrypted_password
        save(:validate => false)
      else
        return false unless BCrypt::Password.new(password_digest) == unencrypted_password
      end
      self
    end

    def password=(unencrypted_password)
      @password = unencrypted_password
      unless unencrypted_password.blank?
        self.password_digest = BCrypt::Password.create(unencrypted_password)
      end
    end

    def full_name
      "#{first_name} #{last_name}".strip
    end

    def confirmed?
      !!self.confirmed_at
    end

    def send_confirmation_instructions!(region = nil)
      generate_confirmation_token! if self.confirmation_token.nil?

      # I18n will use current locale if the passed one is nil
      I18n.with_locale(region.try(:locale)) do
        AuthMailer.confirmation_instructions(self).deliver
      end
    end

    def confirm!
      return if self.confirmed?
      self.confirmation_token = nil
      self.confirmed_at = Time.now
      customer.verified = true
      save(:validate => false)
    end

    def send_reset_password_instructions!(region = nil)
      generate_reset_password_token! if self.reset_password_token.nil?

      I18n.with_locale(region.try(:locale)) do
        AuthMailer.reset_password_instructions(self, region).deliver
      end
    end

    def reset_password!(new_password, new_password_confirmation)
      self.password = new_password
      self.password_confirmation = new_password_confirmation
      if valid?
        reset_authentication_token
        self.reset_password_token = nil
        self.reset_password_sent_at = nil
      end
      save
    end

    def avatar_url
      if avatar.present?
        avatar.url
      elsif fb_uid.present?
        "http://graph.facebook.com/#{fb_uid}/picture"
      else
        "no-avatar.png"
      end
    end

    def track_sign_in!
      self.last_sign_in_at = Time.now
      self.sign_in_count ||= 0
      self.sign_in_count += 1
      save(:validate => false)
    end

    def connected_with_facebook?
      self.fb_uid.present?
    end

    def pending_reservations
      customer.reservations.pending_reservations
    end

    def owns_reservation?(rsv_id)
      self.pending_reservations.any? do |res|
        res[:id] == rsv_id
      end
    end

    def default_region
      RCore::Region.find(self.region)
    end

    def default_country
      RCore::Country.find(self.country)
    end

    def secret_token
      Digest::SHA1.hexdigest(self.id.to_s + Rails.application.config.secret_token)
    end

    # Creates many referrals at once without the need of repeating common attributes.
    #
    # Strategy and origin are common attributes and there is no need to include them
    # in each item of the attributes array.
    #
    def create_referrals(strategy, origin, attributes)
      self.referrals.create attributes do |r|
        r.strategy = strategy
        r.origin   = origin
      end
    end

    [:currency, :credit_cents, :first_name, :last_name, :email, :phone,
     :phone_prefix, :country, :region].each do |attribute|
      delegate attribute, to: :customer
      define_method "#{attribute}=" do |value|
        build_customer unless customer
        customer.send "#{attribute}=", value
      end
    end

    def credit=(credit)
      build_customer unless customer
      customer.credit = credit
    end

    def ensure_authentication_token!
      reset_authentication_token! if authentication_token.blank?
      true
    end

    def first_origin
      customer.reservations.order(:created_at).first.try(:origin)
    end

    private

    def normalize_res_data(res_data)
      r_ids = Set.new(res_data.map { |res| res[:restaurant_id] })
      restaurants = Restaurant.published.where(:id => r_ids.to_a)
      res_data.map do |res|
        res[:date] = Date.parse(res[:date])
        res[:is_today] = true if res[:date] == Date.current
        res[:restaurant] = restaurants.select { |r| r.id == res[:restaurant_id] }.first
        res[:restaurant].present? ? res : nil
      end.reject { |res| res.nil? }
    end

    def reset_authentication_token!
      reset_authentication_token
      update_column :authentication_token, authentication_token
    end

    def reset_authentication_token
      tokens = [Time.now, self.id, self.class.generate_token]
      self.authentication_token = Digest::SHA1.hexdigest(tokens.flatten.join('--'))
    end

    def generate_confirmation_token!
      self.confirmation_token = loop do
        token = self.class.generate_token
        break token unless self.class.find_by_confirmation_token(token)
      end
      self.confirmed_at = nil
      self.confirmation_sent_at = Time.now.utc
      save(:validate => false)
    end

    def generate_reset_password_token!
      self.reset_password_token = loop do
        token = self.class.generate_token
        break token unless self.class.find_by_reset_password_token(token)
      end
      self.reset_password_sent_at = Time.now.utc
      save(:validate => false)
    end

    def initialize_customer
      build_customer unless customer_id? || customer.present?
    end
  end
end
