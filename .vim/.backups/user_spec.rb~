require 'spec_helper'
require 'public_api_spec_helper'

describe "RedoApp::PublicApi" do

  let(:user_params) do
    user_data = Factory.attributes_for(:user).slice(:first_name, :last_name, :email, :password)
    { :user => user_data }
  end

  context "POST /users" do
    it "signups the user" do
      Redo::User.any_instance.stub(:send_confirmation_instructions!)

      post "/users", user_params

      last_response.status.should == 201
      user = Redo::User.find_by_email(user_params[:user][:email])

      json_response["user"].should include({
        "id" => user.id,
        "first_name" => user.first_name,
        "last_name" => user.last_name,
        "email" => user.email,
        "points" => RedoApp.signup_points
      })
    end

    it "returns an error if the user is already registered" do
      Redo::User.create(user_params[:user].merge(:registered => true))

      post "/users", user_params
      last_response.status.should == 422

      json_response["code"].should == 'already_registered'
      json_response["errors"].should == [I18n.t('users.errors.already_registered')]
    end

    it "returns the error list if the user attributes were not valid" do
      user_params[:user].merge!(:email => "invalid_email")

      post "/users", user_params
      last_response.status.should == 422

      json_response["code"].should == 'invalid_attributes'
      json_response["errors"].should include("E-Mail email must be valid")
    end

    context "Facebook Connect" do

      let(:access_token) { "fbtoken12345" }
      let(:graph) { double("Koala::Facebook::API instance") }

      let(:fb_profile) do
        {
          "id" => "123",
          "first_name" => "Daniel",
          "last_name" => "Lopez",
          "email" => "dani@gmail.com",
          "birthday" => "06/08/1984",
        }
      end

      let(:expected_user) do
        {
          "first_name" => fb_profile["first_name"],
          "last_name" => fb_profile["last_name"],
          "email" => fb_profile["email"],
          "birthday" => "1984-06-08",
          "points" => RedoApp.signup_points,
          "fb_uid" => fb_profile["id"],
          "avatar" => "http://graph.facebook.com/123/picture"
        }
      end

      before do
        Koala::Facebook::API.stub(:new)
          .with(access_token)
          .and_return(graph)

        graph.stub(:get_object).with("me")
          .and_return(fb_profile)
      end

      it "signups the user with facebook" do
        expected_user["authentication_token"] = "fakeAuthToken123123123123"
        Redo::User.any_instance.stub(:authentication_token).and_return(expected_user["authentication_token"])

        post "/users", fb_token: access_token
        json_response["user"].should include(expected_user)
      end

      it "returns the user data if the user exists" do
        # Create user
        post "/users", fb_token: access_token

        Redo::User.should_not_receive(:signup_with_facebook!)

        post "/users", fb_token: access_token
        json_response["user"].should include(expected_user)
      end

      it "returns a 401 if token is not valid" do
        graph.stub(:get_object).with("me")
          .and_raise(Koala::Facebook::APIError.new(401, "401 Unauthorized"))

        post "/users", fb_token: access_token
        last_response.status.should == 401
      end

    end
  end

  context "POST /users/password" do
    it "resets the user password" do
      (mailer = stub("mailer")).should_receive(:deliver)
      Redo::AuthMailer.should_receive(:reset_password_instructions).and_return(mailer)

      user = Factory(:user, :registered => true)
      post "/users/password", :email => user.email

      last_response.status.should == 201
      user.reload.reset_password_token.should_not be_nil
    end

    it "returns a 404 if the user doesn't exist" do
      post "/users/password", :email => "inexistent@email.com"

      last_response.status.should == 404
    end

    it "returns a 422 if email is not specified" do
      post "/users/password"

      last_response.status.should == 422
      json_response["code"].should == "missing_params"
    end
  end

  context "Private resources" do

    before do
      @restaurant = Factory(:restaurant_full_published)
      @reservation_1 = Factory(:reservation, customer: user.customer, restaurant: @restaurant)
      @reservation_2 = Factory(:reservation, customer: user.customer)
    end

    before(:each) do
      authorize user.email, user.password
    end

    let(:user) { Factory(:user_full) }

    context "GET /users/me" do

      it "should include authentication_token in the response when authenticated with Basic Authentication" do

        # TODO: We should call here the authorize method for basic authentication and
        # remove it from the before_each block.
        get "/users/me"
        last_response.status.should == 200
        json_response["user"].should include({
          "authentication_token" => user.authentication_token
        })
      end

      it "returns a 401 if no password is provided" do
        header "Authorization", "Basic dXNlckBlbWFpbC5jb20="

        get "/users/me"
        last_response.status.should == 401
      end

      it "returns a json representation of the user's profile (no avatar)" do
        Factory(:review, :user => user)

        get "/users/me"

        last_response.status.should == 200
        json_response["user"].should == {
          "avatar" => "http://localhost:3001/assets/no-avatar.png",
          "birthday" => user.birthday.to_s,
          "email" => user.email,
          "first_name" => user.first_name,
          "last_name" => user.last_name,
          "phone" => user.phone,
          "country" => user.country,
          "region" => user.region,
          "points" => user.points,
          "id" => user.id,
          "fb_uid" => nil,
          "accepts_emails" => true,
          "pending_reservations" => 2,
          "pending_reviews" => 1,
          "authentication_token" => user.authentication_token
        }
      end

      it "excludes the specified fields" do
        get "/users/me?exclude_fields=points,pending_reservations,pending_reviews,fb_uid"

        last_response.status.should == 200
        json_response["user"].should == {
          "avatar" => "http://localhost:3001/assets/no-avatar.png",
          "birthday" => user.birthday.to_s,
          "email" => user.email,
          "first_name" => user.first_name,
          "last_name" => user.last_name,
          "phone" => user.phone,
          "country" => user.country,
          "region" => user.region,
          "id" => user.id,
          "accepts_emails" => true,
          "authentication_token" => user.authentication_token
        }
      end

      it "includes the specified fields" do
        get "/users/me?include_fields=points,pending_reservations"
        last_response.status.should == 200
        json_response["user"].should == {
          "points" => user.points,
          "pending_reservations" => 2
        }
      end

      it "returns a 400 if include and exclude params are present" do
        get "/users/me?include_fields=points&exclude_fields=pending_reservations"

        last_response.status.should == 400
      end

      it "returns a json representation of the user's profile (FB avatar)" do
        user.update_attribute(:fb_uid, "2387873298")

        get "/users/me"
        last_response.status.should == 200
        json_response["user"]["avatar"].should == "http://graph.facebook.com/2387873298/picture"
      end

      it "returns a 401 if bad credentials are passed" do
        authorize user.email, "bad password"
        get "/users/me"
        last_response.status.should == 401
      end

      it "returns a 401 if email belongs to no user" do
        authorize "bad@email.com", "badpassword"
        get "/users/me"
        last_response.status.should == 401
      end

      it "returns a 401 if nocredentials are passed" do
        no_authentication!
        get "/users/me"
        last_response.status.should == 401
      end

    end

    context "PUT /users/:id" do

      let(:user_data) do
        {
          :user => {
            :first_name => "Roberto",
            :last_name => "Mendoza",
            :phone => "155-222-1111",
            :password => "newpassword",
            :birthday => "1995-09-10",
            :region => "buenos-aires",
            :points => 10000,
            :country => "ar",
            :email => "new_email@gmail.com",
            :accepts_emails => true
          }
        }
      end

      context "Unregistered user" do

        before do
          no_authentication!
        end

        let(:user) { Factory(:user, password: nil, email: user_data[:user][:email]) }

        it "signs up the user" do
          Redo::User.any_instance.stub(:send_confirmation_instructions!)
          user_data[:user][:secret_token] = user.secret_token

          user.password_digest.should be_nil

          put "/users/#{user.id}", user_data

          last_response.status.should == 200
          json_response["user"].should include({
            "first_name" => "Roberto",
            "last_name" => "Mendoza",
            "phone" => "155-222-1111",
            "email" => user.email
          })
          user.reload.password_digest.should_not be_nil
        end

        it "returns the errors if the user is invalid" do
          user_data[:user][:secret_token] = user.secret_token
          user_data[:user][:first_name] = ""
          put "/users/#{user.id}", user_data

          last_response.status.should == 422
          json_response.should include({
            "code" => "invalid_attributes",
            "message" => "User attributes are not valid"
          })
          json_response['errors'].should have(2).errors
        end

        it "returns a 401 if there is no secret_token" do
           put "/users/#{user.id}", user_data
           last_response.status.should == 401
        end

        it "returns a 401 if the secret_token is invalid" do
          user_data[:user][:secret_token] = "abcdef"
          put "/users/#{user.id}", user_data

          last_response.status.should == 401
        end

      end

      context "Registered user" do

        it "updates the allowed user attributes" do
          put "/users/me", user_data

          last_response.status.should == 200
          json_response["user"].should include({
            "first_name" => "Roberto",
            "last_name" => "Mendoza",
            "phone" => "155-222-1111",
            "birthday" => "1995-09-10",
            "accepts_emails" => true,
            "region" => "sao-paulo", # region cannot be updated
            "country" => "br", # country cannot be updated
            "email" => user.email, # email cannot be updated
            "points" => user.points # cannot be updated
          })
        end

        it "updates the password" do
          expect {
            put "/users/me", user_data
          }.to change(user, :password_digest)
        end

        it "doesn't update the id" do
          expect {
            put "/users/me", user_data
          }.to_not change(user, :id)
        end

        it "returns the errors if the user is invalid" do
          user_data[:user][:first_name] = ""
          put "/users/me", user_data

          last_response.status.should == 422
          json_response.should include({
            "code" => "invalid_attributes",
            "message" => "User attributes are not valid"
          })
          json_response["errors"].should have(2).errors
        end

      end

      context "Non existent user" do

        it "returns a 404" do
          no_authentication!
          put "/users/12", user_data

          last_response.status.should == 404
        end

      end
    end

    pending "Favorites temporarily disabled" do
      context "Favorites" do

        context "GET /users/me/favorites" do

          it "returns a json representation of the user's favorite restaurants" do
            user.favorite_restaurants << @restaurant
            get "/users/me/favorites"

            last_response.status.should == 200
            json_response["restaurants"].should be_kind_of Array
            json_response["restaurants"].should have(1).entry
            json_response["restaurants"].first["name"].should == @restaurant.name
            json_response["total"].should == 1
          end

          it "returns a 401 if bad credentials are passed" do
            authorize user.email, "bad password"
            get "/users/me/favorites"
            last_response.status.should == 401
          end

          context "pagination" do

            before(:all) do
              restaurants = []
              5.times {
                restaurants.push FactoryGirl.create(:restaurant_full_published)
              }
              user.favorite_restaurants = restaurants
            end

            it "returns the first set of restaurants" do
              get "/users/me/favorites", { :per_page => 3 }
              last_response.status.should == 200
              json_response["restaurants"].should have(3).entries
              json_response["total"].should == 5
            end

            it "returns the first set of restaurants" do
              get "/users/me/favorites", { :page => 2, :per_page => 3 }
              last_response.status.should == 200
              json_response["restaurants"].should have(2).entries
              json_response["total"].should == 5
            end

          end

          context "GET /users/me/favorites/:restaurant" do

            it "returns a 404 for a non favorite restaurant" do
              get "/users/me/favorites/#{@restaurant.slug}"
              last_response.status.should be == 404
            end

            it "returns a 401 if bad credentials are passed" do
              authorize user.email, "bad password"
              get "/users/me/favorites/#{@restaurant.slug}"
              last_response.status.should == 401
            end

            it "returns a json representation of a restaurant" do
              user.favorite_restaurants << @restaurant
              get "/users/me/favorites/#{@restaurant.slug}"

              last_response.status.should be == 200
              json_response["restaurant"]["id"].should be == @restaurant.slug
              json_response["restaurant"]["name"].should be == @restaurant.name
            end

          end

          context "PUT /users/me/favorites/:restaurant" do

            it "returns a 404 if a restaurant is not published" do
              restaurant = Factory(:restaurant)
              put "/users/me/favorites/#{restaurant.slug}"
              last_response.status.should == 404
            end

            it "returns a 404 if a restaurant doesn't exist" do
              put "/users/me/favorites/this-restaurant-doesnt-exist"
              last_response.status.should == 404
            end

            it "returns a 401 if bad credentials are passed" do
              authorize user.email, "bad password"
              put "/users/me/favorites/#{@restaurant.slug}"
              last_response.status.should == 401
            end

            it "adds a restaurant as a user's favorite" do
              put "/users/me/favorites/#{@restaurant.slug}"
              last_response.status.should == 200
            end

            it "ignores if the restaurant is already a favorite" do
              put "/users/me/favorites/#{@restaurant.slug}"
              put "/users/me/favorites/#{@restaurant.slug}"
              last_response.status.should == 200
            end

          end

          context "DELETE /users/me/favorites/:restaurant" do

            it "returns a 200 if a restaurant is deleted from favorites" do
              user.favorite_restaurants << @restaurant
              delete "/users/me/favorites/#{@restaurant.slug}"
              last_response.status.should == 200
            end

            it "returns a 401 if bad credentials are passed" do
              authorize user.email, "bad password"
              delete "/users/me/favorites/#{@restaurant.slug}"
              last_response.status.should == 401
            end

            it "returns a 404 if a restaurant is not a user's favorite" do
              delete "/users/me/favorites/#{@restaurant.slug}"
              last_response.status.should == 404
            end

          end

        end
      end
    end

    context "Reservations" do

      context "GET /users/me/reservations" do

        it "returns a list of the user's pending reservations" do
          get "/users/me/reservations?type=pending"

          last_response.status.should be == 200
          json_response["reservations"].should have(2).entries
          first_reservation = json_response['reservations'].find do |reservation|
            reservation['id'] == @reservation_1.id
          end
          first_reservation.should == {
            "id" => @reservation_1.id,
            "date" => @reservation_1.date.to_s,
            "time" => @reservation_1.time.strftime("%H:%M"),
            "diners" => @reservation_1.diners,
            "restaurant" => {
              "id" => @restaurant.slug,
              "name" => @restaurant.name,
              "address" => @restaurant.address,
              "location" => @restaurant.location,
              "phone" => @restaurant.phone,
              "zone" => {
                "id" => @restaurant.zone.slug,
                "name" => @restaurant.zone.name
              }
            }
          }
        end

        it "returns a 501 when listing all reservations" do
          get "/users/me/reservations"

          last_response.status.should == 501
        end

        it "returns a 501 when listing another type of reservations" do
          get "/users/me/reservations?type=canceled"

          last_response.status.should == 501
        end

        it "returns a 401 if the user is not authenticated" do
          no_authentication!
          get "/users/me/reservations?type=pending"

          last_response.status.should == 401
        end
      end

      context "DELETE /restaurants/:restaurant_id/reservations/:id" do

        it "returns a 200 if the reservation was canceled" do
          delete "/restaurants/#{@restaurant.slug}/reservations/#{@reservation_1.id}"

          last_response.status.should == 200
          last_response.body.should == "{}"
        end

        it "returns a 404 id the reservation is not in his pending list" do
          delete "/restaurants/#{@restaurant.slug}/reservations/777"
          last_response.status.should == 404
        end

        it "returns a 404 if the reservation doesn't belong to the specified restaurant" do
          delete "/restaurants/22/reservations/#{@reservation_1.id}"
          last_response.status.should == 404
        end

        it "returns a 401 if the user is not authenticated" do
          no_authentication!
          delete "/restaurants/#{@restaurant.slug}/reservations/#{@reservation_1.id}"
          last_response.status.should == 401
        end
      end
    end
  end

end
